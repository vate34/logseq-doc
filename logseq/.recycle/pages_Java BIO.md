- BIO就是: Blocking IO， ((66a70bcc-d3ac-4c4d-8b44-786d917e4727))  。最容易理解、最容易实现的 IO 工作方式。
	- 应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；
	- 另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；
	- 操作系统在收集数据后，会把数据发送给应用程序；
	- 最后应用程序受到数据，并解除等待状态。
- 其读写都是面向的流，且一次读写一个字节。
- ## 传统的BIO
- 传统的网络通讯方式为阻塞式的，即
- 客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。
- 服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。
  
  **缺点**：同一时间只能接收和处理同一个客户端的请求，在高并发的情况下不能接受。
- ![image.png](../assets/image_1689587595025_0.png)
-
- ## 多线程实现伪异步
- 对于处理请求的部分可以使用多线程来进行处理：
	- 当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。
	- 客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程。
- 缺点：但是由于实际上服务器接受请求的 accept 方法还是单个的，对于报文的接收还是需要一个一个来的。同时使用多线程也会带来额外的资源消耗
- 线程是很”贵”的资源，主要表现在：
	- 1. 线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。
	- 2.	线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。
	- 3.	线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。
	- 4.	容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。