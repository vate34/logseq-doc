# 程序计数器
- 作用：保存当前程序执行的位置（虚拟机字节码指令的地址），便于 JVM 在执行不同线程间进行切换
- 生命周期：每个线程拥有一个程序计数器，与线程的生命周期相同
- 不会出现 OOM
- # 虚拟机栈
- 使用栈桢保存方法执行时的各种信息
- 每个线程独享，与线程的生命周期相同
- 内存不够会抛出 OutOfMemoryError，栈深度过深会抛出 StackOverflowError
- 包含的信息有以下几种：
- > 局部变量表：局部变量表存储方法参数和局部变量（引申：全局变量是放在堆的，有两次赋值的阶段，一次在类加载的准备阶段，赋予系统初始值；另外一次在类加载的初始化阶段，赋予代码定义的初始值。类的加载过程）
- > 操作数栈：当一个方法刚开始执行时，对应的操作栈为空，在实行过程中，会有各种字节指令码的出栈/入栈操作
- > 动态连接：每个栈帧都包含有一个指向运行时常量池中该栈帧所属方法的引用。持有该方法的引用是为了支持方法调用过程中的动态连接
- > 方法返回地址：返回分为 正常返回 和 异常退出。
- # 本地方法栈
- 调用本地 native 方法，不受 JVM 控制
- 可能会抛出 StackOverflowError 和 OutOfMemoryError
- # 堆区
- 堆区是被所有线程共享的区域
- 此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在此处分配内存。
- 堆是垃圾收集器管理的主要区域，又称为“GC堆”
- # ~~方法区~~
- 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 会抛出 OOM 错误
- > JDK 8 中废弃了“永久代”的概念
- # 运行时常量池
- 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。会抛出 OOM 错误
- # 直接内存
- # 元空间
- 没有使用堆内存，而是使用与堆不相连的本地内存区域
- 不会出现内存溢出问题