- 事务传播机制就是，多个事务方法互相调用时，事务如何在这些方法间传播。
- > 举个栗子，方法 A 是一个事务的方法，方法 A 执行过程中调用了方法 B。那么方法 B 有无事务以及方法 B 对事务的要求不同，都会对方法 A 的事务具体执行造成影响；同时方法 A 的事务对方法 B 的事务执行也有影响。这种影响具体是什么就由两个方法所定义的事务传播类型所决定。
- 在Spring中对于事务的传播行为定义了七种类型分别是：**REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED**。
- 可以根据是否支持当前事务来划分为三类：
	- ## 支持当前事务
		- **`REQUIRED`**，如果当前存在事务，则使用该事务。 如果当前没有事务，则创建一个新的事务。是 Spring 默认的事务传播机制。
		- **`SUPPORTS`**，如果当前存在事务，则使用该事务，如果当前不存在事务，则仍以非事务的方式运行。
		- **`MANDATORY`**，如果当前存在事务，则使用该事务，如果当前事务不存在则抛出异常。
	- ## 不支持当前事务
		- **`REQUIRED_NEW`**，总是创建一个新的事务，如果当前有事务，则将当前事务挂起。
			- 可以理解为设置事务传播类型为REQUIRES_NEW的方法，在执行时，不论当前是否存在事务，总是会新建一个事务。
		- **`NOT_SUPPORTED`**，始终以非事务的方式运行，如果当前有事务，则将当前事务挂起。
			- 可以理解为设置事务传播类型为NOT_SUPPORTED的方法，在执行时，不论当前是否存在事务，都会以非事务的方式运行。
		- **`NEVER`**，始终以非事务的方式运行，如果当前有事务，则抛出异常。
			- 很容易理解，就是我这个方法不使用事务，并且调用我的方法也不允许有事务，如果调用我的方法有事务则我直接抛出异常。
	- ## 嵌套事务
		- **`NESTED`**，当前存在事务，则创建一个嵌套事务来运行，如果当前没有事务，则和 `REQUIRED`一样开启一个事务运行。
			- 和REQUIRES_NEW的区别
			  > REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。
			  在NESTED情况下父事务回滚时，子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。
			- 和REQUIRED的区别
			  > REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚
			  而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响
- # 详细场景
	- [一文搞懂Spring事务传播机制](https://juejin.cn/post/6870790953922215950)
	- [带你读懂Spring 事务——事务的传播机制](https://zhuanlan.zhihu.com/p/148504094)