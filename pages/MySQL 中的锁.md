- |分类|类型|
  |--|--|
  |按粒度分类|全局锁、表级锁、页级锁、行级锁|
  |按模式分类|乐观锁、悲观锁|
  |按属性分类|共享锁、排他锁（读/写锁）|
  |按状态分类|意向共享锁、意向排他锁|
  |按算法分类|间隙锁、记录锁、临键锁|
- # 粒度锁
- ## 1. 全局锁
- 全局锁就是对整个数据库实例加锁。
- 应用的场景为全库逻辑备份（mysqldump）。
- **实现方式**为使用命令：`Flush tables with read lock `(FTWRL)，使用后整个库处于只读状态，数据更新语句、数据定义语句和更新类事务的提交语句，都会被阻塞。
- **风险点**：
	- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。
	- 如果在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。
- **解决方案**：
	- `mysqldump`使用参数`--single-transaction`，启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
- ## 2. 表级锁
- 对当前操作的整张表加锁。
- MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
- **实现方式**：
	- 表锁：`lock tables … read/write`
		- > 例如lock tables t1 read, t2 write; 命令，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能在unlock tables之前访问其他表。
	- 元数据锁：MDL不需要显式使用，在访问一个表的时候会被自动加上 ：
		- 对一个表做增删改查的时候，加MDL读锁
		- 对表结构做变更操作时，加MDL写锁
- **风险点**：
	- 给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。
	- 添加MDL读锁后不会立即释放（事务完成后才释放），此时再添加MDL写锁，会使整张表完全不可读写。
- **解决方案**：
	- 解决长事务。
	- 低峰期做DDL变更。
- ## 3. 页级锁
- 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。
- 表级锁速度快，但冲突多，行级锁冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。
- 会出现死锁，并发处理能力一般。
- ## 4. 行级锁
- 行级锁是粒度最低的锁，发生锁冲突的概率也最低、并发度最高。但是加锁慢、开销大，容易发生死锁现象。
- MySQL中只有InnoDB支持行级锁，行级锁分为共享锁和排他锁。
- **实现方式**：
	- 在MySQL中，行级锁并不是直接锁记录，而是锁索引
		- 如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；
		- 如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。
		- 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。
- # 乐观锁与悲观锁
- [[乐观锁、悲观锁与自旋锁]]
- ## 1. 乐观锁
	- 乐观锁是相对悲观锁而言的，**乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测**，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。
	- 应用场景为读多写少的场景，如果出现大量写操作，写冲突的可能性就会增大，业务层需要不断重试，会大大降低系统性能。
	- **实现方式**：
		- 一般使用数据版本（Version）记录机制实现，在数据库表中增加一个数字类型的“version”字段来实现。
		- 当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。
		- 当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
- ## 2. 悲观锁
	- 悲观锁具有强烈的独占和排他特性，每次获取数据时，都认为其他事务会处理数据，因此将数据加锁处于锁定状态。
	- 应用场景：适用于并发量不大、写入操作比较频繁、数据一致性比较高的场景。
	- **实现方式**：
		- 关闭MySQL 的自动提交：`set autocommit=0`。
		- `select...for update`是MySQL提供的实现悲观锁的方式，属于排它锁。
			- > 此时MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。
		- **共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。**
- # 共享锁与排他锁
	- ## 1. 共享锁/读锁
		- 共享锁，又称之为读锁，简称S锁，当**事务A对数据加上读锁后，其他事务只能对该数据加读锁**，不能做任何修改操作，也就是不能添加写锁。
		- 应用场景：共享锁主要是为了支持并发的读取数据而出现的，读取数据时，不允许其他事务对当前数据进行修改操作，从而避免”不可重读”的问题的出现。
		- **实现方式**：`select …lock in share mode`
- ## 2. 排他锁/写锁
	- 排它锁，又称之为写锁，简称X锁，当事务对数据加上写锁后，其他事务既不能对该数据添加读写，也不能对该数据添加写锁，**写锁与其他锁都是互斥的**。
	- MySQL InnoDB引擎默认update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。
	- 应用场景：写锁主要是为了解决在修改数据时，不允许其他事务对当前数据进行修改和读取操作，从而可以有效避免”脏读”问题的产生。
	- **实现方式：**
		- 增删改操作
		- `select...for update`
- # 意向锁
	- 意向锁分为意向共享锁和意向排他锁。
	- 意向锁是表锁，为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。
	- 当有事务A有行锁时，MySQL会自动为该表添加意向锁，事务B如果想申请整个表的写锁，那么不需要遍历每一行判断是否存在行锁，而直接判断是否存在意向锁，增强性能。
- # 间隙锁、临键锁、记录锁
  记录锁、间隙锁、临键锁都是排它锁的实现方式。
	- ## 1. 记录锁
		- 记录锁，即封锁记录，对数据行加锁，也叫行锁。
		- `select * from goods where id = 1 for update`
	- ## 2. 间隙锁
		- 间隙锁基于非唯一索引，它锁定一段范围内的索引记录，**用于解决幻读问题**。
		- **使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据**。例如：
		- `select * from goods where id between 1 and 10 for update`
		- 所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1和 10 两条记录行并不会被锁住
		- > 如果是唯一索引的等值查询的话，间隙锁会退化为记录锁
		  如：`select * from goods where id = 1`
	- ## 3. 临键锁
		- 临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间，是一个左开右闭区间。
		- 临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。
		- > 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。
		  需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。
-
- 参考：[史上最全MySQL各种锁详解](https://juejin.cn/post/6931752749545553933)