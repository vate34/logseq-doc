# 特点
- 高性能。运行在内存中，速度快
  logseq.order-list-type:: number
- 高并发。使用单线程；多路I/O复用模型，非阻塞式IO
  logseq.order-list-type:: number
- 操作原子性
  logseq.order-list-type:: number
- # 数据类型
- **字符串**。可以是字符串、整数或浮点数。对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作。
  logseq.order-list-type:: number
- List 列表**。一个链表，链表上的每个节点都包含一个字符串。对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；**
  logseq.order-list-type:: number
- Set 集合**。包含字符串的无序集合。字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等**
  logseq.order-list-type:: number
- Hash 散列**。包含键值对的无序散列表。包含方法有添加、获取、删除单个元素**
  logseq.order-list-type:: number
- Zset有序集合**。和散列一样，用于存储键值对。字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素
  logseq.order-list-type:: number
- HyperLogLogs 基数统计。这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。
  logseq.order-list-type:: number
- Bitmap 位存储。Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。
  logseq.order-list-type:: number
- Geospatial 地理位置。保存地理信息。geo底层的实现原理实际上就是Zset, 我们可以通过Zset命令来操作geo
  logseq.order-list-type:: number
- Stream
  logseq.order-list-type:: number
- # 持久化
- ## RDB
- 快照，持久化的默认方式。这种方式是定期将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。
- **优点**
	- 性能最大化。使用了子线程来操作
	  logseq.order-list-type:: number
	- 大数据集情况下，比 AOF 启动效率高
	  logseq.order-list-type:: number
- **缺点**
	- 数据安全性低。可能会出现数据丢失情况
	  logseq.order-list-type:: number
	- 使用子线程协助完成，可能会导致服务器停机几百毫秒
	  logseq.order-list-type:: number
- ## AOF
- 在使用 aof 持久化方式时，redis 会将收到的写命令都通过 write 函数追加到文件中(默认是 appendonly.aof)。
- **优点**
	- 1. 数据安全
- **缺点**
	- 1. 文件大，恢复慢。（文件较大的问题可以通过触发AOF重写解决）
	- 2. 数据集大的时候，启动慢
- # 事务
- Redis 事务的本质是通过 MULTI、EXEC、WATCH 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。
- **Redis 不支持回滚**，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
  logseq.order-list-type:: number
- 如果在一个事务中的命令出现错误，那么所有的命令都不会执行**；**
  logseq.order-list-type:: number
- 如果在一个事务中出现运行错误，那么正确的命令会被执行**。
  logseq.order-list-type:: number
- # 删除策略
- 定时删除。对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。
  logseq.order-list-type:: number
	- 优点：这种方式立即清除过期数据，对内存比较好。
	- 缺点：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量和响应时间。
- 惰性删除。当访问一个 key 的时候，才会判断该 key 是否过期，如果过期就删除。
  logseq.order-list-type:: number
	- 优点：该方式能最大限度节省 CPU 的资源。
	- 缺点：但是对内存不太好，有一种比较极端的情况：出现大量的过期 key 没有被再次访问，因为不会被清除，导致占用了大量的内存。
- 定期删除。每隔一段时间，扫描redis 中过期key 的字典，并清除部分过期的key。这种方式是前俩种一种折中方法。不同的情况下，调整定时扫描时间间隔，让CPU 与 内存达到最优。
  logseq.order-list-type:: number
- # 内存淘汰策略
- Redis 内存淘汰策略是指达到maxmemory极限时，使用某种算法来决定来清理哪些数据，以保证新数据存入。
- 不处理，等报错（默认配置）。发现内存不够时，不删除key，执行写入命令时直接返回错误信息。
  logseq.order-list-type:: number
- 从所有的结果集中的 key 中挑选，进行淘汰
  logseq.order-list-type:: number
- 从设置了过期时间的 key 中挑选，进行淘汰
  logseq.order-list-type:: number
- # 单线程
- Redis 命令的核心模块是单线程的，与服务端的连接、事件处理是多线程的。原因：
- 基于内存的操作，**CPU 不是性能瓶颈，瓶颈是网络开销和机器内存**。多线程的目的是提高 CPU 的利用率，在此处不是必要的
  logseq.order-list-type:: number
- **多线程操作会引入锁**，以及线程切换等功能，会消耗CPU
  logseq.order-list-type:: number
- 单线程的核心是使用了[[IO多路复用模型]]，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络 I/O 的时间消耗)
  logseq.order-list-type:: number
- 多线程：也有可以异步处理的删除操作，用于避免删除数据消耗了不必要的时间
  logseq.order-list-type:: number
- # 异常与异常处理
- ## 缓存雪崩
- **缓存雪崩**是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。解决方案：
- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
  logseq.order-list-type:: number
- 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
  logseq.order-list-type:: number
- 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。
  logseq.order-list-type:: number
- 不设置过期时间,更新的时候只更新缓存即可。
  logseq.order-list-type:: number
- ## 缓存击穿
- 缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，而缓存击穿是**某个热点的 key 失效，大并发集中对其进行请求**，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。解决方案：
- 对热点数据的读取加锁或队列。在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个 key 只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
  logseq.order-list-type:: number
- 热点数据缓存永远不过期。
  logseq.order-list-type:: number
- ## 缓存穿透
- 缓存穿透是指用户请求的数据在缓存中不存在即**没有命中**，同时在**数据库中也不存在**，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。
- 解决方案
- 将无效的 key 放到 Redis 中。
  logseq.order-list-type:: number
- 使用布隆过滤器。
  logseq.order-list-type:: number
- > 如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在 (存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有 key 都存储在布隆过滤器中，在查询 Redis 前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。
  **如何选择**：针对一些恶意攻击，攻击带过来的大量 key 是随机，那么我们采用第一种方案就会缓存大量不存在 key 的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些 key。所以，针对这种 key 异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的 key 有限的，重复率比较高的，则可优先采用第一种方式进行缓存。
- # 集群
- Redis有三种集群模式：
	- 主从复制模式
	- Sentinel（哨兵）模式
	- Cluster 模式
- ## 主从复制模式
- **Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上**。
- 在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。
	- **主数据库可以进行读写操作**，当写操作导致数据变化时会自动将数据同步给从数据库。
	- **从数据库一般是只读的**，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。
- ### 作用
- 读写分离，减轻主数据库的读写压力
  logseq.order-list-type:: number
- 方便做容灾备份
  logseq.order-list-type:: number
- ### 阶段
- 建立连接、协商同步
  logseq.order-list-type:: number
- 主库将所有数据同步给从库。 这个过程依赖于内存快照生成的 RDB 文件。
  logseq.order-list-type:: number
- 主库会把上一阶段执行过程中收到的写命令，再发送给从库
  logseq.order-list-type:: number
- ## 哨兵模式
- 主从复制模式在主服务器宕机之后，需要手动切换主服务器，费事且会造成一段时间内服务不可用。
- 哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，**哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例**。
- ## 作用
- 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器；
- 当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机；
- 然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。
- ## Cluster 集群模式
- Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，**也就是说每台 Redis 节点上存储不同的内容**。
- ### 集群的数据分片
- Redis 集群没有使用一致性 hash，而是引入了哈希槽【hash slot】的概念。Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分hash槽。
- 这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D ， 我需要从节点 A， B， C 中得部分槽到 D 上。如果我想移除节点 A ，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。
- ### 主从复制模型
- 为了保证高可用，redis-cluster集群引入了主从复制模型，一个主节点对应一个或者多个从节点，当**主节点宕机的时候，就会启用从节点**。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点 A1 都宕机了，那么该集群就无法再提供服务了。