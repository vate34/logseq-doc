# 分代收集理论
	- 1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
	  2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
	  3. 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。
- # 标记-清除算法
	- 分为“标记”和“清除”两个阶段：**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象**。
	- **缺点：**
		- 1. 效率问题。两个过程需要暂停应用，效率不高
		- 2. 标记清除后，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，**无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作**。
- # 标记-复制算法
	- 复制算法将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象**复制到另外一块上面**，然后再把**已经使用过的内存空间一次性清理掉**。
	- **优点：**
		- 1. 对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象
		- 2. 分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可
	- **缺点:**
		- 1. 内存空间缩减为原来的一半
		- 2. 算法的效率和存活对象的数目有关，存活对象越多，效率越低
- # 标记-整理算法
	- > 复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。
	- 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后**直接清理掉端边界以外的内存**
	- **缺点：**
		- 移动大量对象是较为繁重的操作，并且需要暂停用户线程
- # 分代收集算法
	- 目前大部分的JVM都采用该算法。据对象存活周期的不同将内存划分为几块并采用不用的垃圾收集算法。
	- 一般是把 Java 堆分为**新生代和老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。
		- 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。
		- 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 **“标记—清除” 或者 “标记—整理”** 算法来进行回收。
	- 如何记录年龄：实例对象每经过一次GC，年龄就+1。
	- 分代收集：对年轻代进行整体GC时使用标记-清除算法，会有内存碎片。eden、survivor区、老年代的复制移动使用的是复制算法。