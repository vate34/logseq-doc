- 索引的目的是为了提高数据查询的效率。大多数情况下，索引查询是比全表扫描要快的，在数据量不大的情况下，使用索引也不一定能够带来很大的提升。
- # 索引类型
	- 根据数据结构维度
	  logseq.order-list-type:: number
		- `B+`树索引。所有数据存储在叶子节点，复杂度为`O(logn)`，适合范围查询。
		  logseq.order-list-type:: number
		- MySQL的InnoDB使用`B+树`作为索引引擎，原因：
			- 为了**减少磁盘读取次数**，树的高度不能很高，不能使用二叉树和平衡二叉树。
			  logseq.order-list-type:: number
			- **B+树非叶子节点不存储数据**，那么innoDB中页（默认大小16KB）中就可以存储更多键值对，相应的阶数就会更大（N值），**树就会更矮，查询效率会更高**。
			  logseq.order-list-type:: number
			- B+树索引的所**有数据存储在叶子节点**，都是**按照顺序排列的**，使用链表连接。范围查找、排序查找、分组查找去重查找都变得简单
			  logseq.order-list-type:: number
		- 哈希索引：适合等值查询，不支持顺序和范围查询。
		  logseq.order-list-type:: number
		- 全文索引：一般在文本类型`char`、`text`、`varchar`类型上创建。
		  logseq.order-list-type:: number
		- `R-Tree`索引: 用来对`GIS`数据类型创建`SPATIAL`索引
		  logseq.order-list-type:: number
	- 根据物理存储维度
	  logseq.order-list-type:: number
		- 聚集索引：以主键创建的索引，在叶子节点存储的是表中的数据。
		  logseq.order-list-type:: number
		- 非聚集索引：以非主键列创建的索引，在叶子节点存储的是索引列和主键。
		  logseq.order-list-type:: number
	- 逻辑维度
	  logseq.order-list-type:: number
		- 联合索引：多个字段创建的索引，使用时遵循最左匹配原则。
		  logseq.order-list-type:: number
		- 唯一索引：索引列中的值必须唯一，允许空值。
		  logseq.order-list-type:: number
		- 主键索引
		  logseq.order-list-type:: number
		- 普通索引
		  logseq.order-list-type:: number
- # 唯一索引与普通索引
	- **结构差异**
		- 普通索引的索引列的数据可以重复。
		- 唯一索引的索引列的数据不允许重复，可以有一条null数据。
	- **查询过程差异：**
		- 普通索引：查询到多一个满足条件的记录后，继续查找下一个记录，直到碰到不满足条件的记录。
		- 唯一索引：查询到第一个满足条件的记录，就停止搜索。
		- 实际性能差异极小：由于InnoDB 的数据是按数据页为单位来读写，普通索引的下一个记录大概率在当前页（在内存中）。
	- **更新过程差异：**
		- 普通索引：会使用`change buffer`来加速更新过程。参见： [[MySQL 的 Change Buffer]]
		- 唯一索引：更新需要判断是否符合唯一性约束，因此需要把数据读取到内存中对比，就没有再使用`change buffer`了。
- # 回表与覆盖索引
  id:: 64e960c6-6609-4d9a-8264-c203a650f303
	- 由于普通二级索引的叶子节点的值，是不包含数据只存储了主键，因此查询后需要到主键索引去查询数据，这个过程叫做回表。
	- 如果要查询的列，包含在二级索引的键上的话，那么查询数据列直接从二级索引中就能够获取到，不需要回表。也就是说，查询列被所建的索引覆盖了。如索引是`idx(a, b, c)`，那么`select b, c from table where a = 1123`语句就是被索引覆盖了。
	- 覆盖索引是按照键值对的顺序存储的，因此覆盖索引把随机读取的 IO 查询，转变为索引查询的顺序 IO。
- # 索引优化
	- ## 最左前缀原则
		- 联合索引的前几个索引值可以根据最左前缀原则，使用这个联合索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
		- 原理：B+树排列的顺序中，在前一个索引值相同的情况下，第二个索引值是排过序的。
		- 参考： https://www.cnblogs.com/rjzheng/p/12557314.html
	- ## 索引下推
		- 对于查询条件无法因为最左前缀原则，命中联合索引的语句，如果查询条件中包涵了索引列，在索引的遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
- ## Explain命令
	- `explain`语句可以查看SQL的执行计划。重要字段：
	- **type：提供了判断查询是否高效的重要依据依据。type 常用的值：**
		- `system` 表示只有一条数据
		- `const` 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据
		- `eq_ref` 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 `=`, 查询效率较高
		- `ref` 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀规则索引的查询.
		- `range` 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 `=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN()` 操作中.
		- `index` 表示全索引扫描(full index scan)。index 类型则仅仅扫描所有的索引, 而不扫描数据.
		- `all` 全表扫描
	- **possible_keys：**
		- `possible_keys` 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 `possible_keys` 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 `key` 字段决定.
	- **key**
		- 此字段是 MySQL 在当前查询时所真正使用到的索引
	- **key_len**
		- 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到
	- **rows**
		- MySQL 查询优化器根据统计信息, **估算** SQL 要查找到结果集需要扫描读取的数据行数.
	- **Extra**
		- `Using filesort`：当 Extra 中有 `Using filesort` 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 `Using filesort`, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.
		- `Using index`："覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错
		- `Using temporary`：查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.
- ## 常见优化措施
  id:: 64e960c6-21a8-4575-a062-b1a3eecb5ad4
	- 尽量避免 `select *`，只查询必要的列
	- 应尽量避免在 `where` 子句中使用 `!=` 或 `<>` 操作符，否则将引擎放弃使用索引而进行全表扫描。
	- 应尽量避免在 `where` 子句中使用 `or` 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描
	- `in` 和 `not in` 也要慎用，可能会导致全表扫描
	- 字符串搜索不要使用前置 `%` 搜索
	- 避免强制类型转换